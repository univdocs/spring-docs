# 7.8.3. 测试Spring Boot应用程序

Spring Boot应用程序是一个Spring `ApplicationContext`，因此，测试Spring Boot应用程序时，除了在Spring上下文中所做的那些事情之外，不需要做任何特别的事情。

<univ-note type="note">

Spring Boot的外部属性、日志记录和其他特性，只有在使用`SpringApplication`来创建时，才会默认安装在上下文中。

</univ-note>

Spring Boot提供了`@SpringBootTest`注解，需要Spring Boot的特性时，可以使用这个注解来替代`spring-test`的标准`@ContextConfiguration`注解。这个注解的作用是通过`SpringApplication`来创建测试中需要使用的`ApplicationContext`。除了`@SpringBootTest`，Spring Boot还提供了许多注解，用于测试应用程序的具体层面。

<univ-note type="note">

使用`JUnit 4`时，记得在测试中添加`@RunWith(SpringRunner.class)`，否则其他注解将会被忽略。使用`JUnit 5`时，不需要添加等效的`@ExtendWith(SpringExtension.class)`，因为`@SpringBootTest`和其他`@...Test`注解已经已经使用了`@ExtendWith(SpringExtension.class)`注解。

</univ-note>

默认情况下，`@SpringBootTest`不会启动服务器。可以使用`@SpringBootTest`的`webEnvironment`属性来进一步细化测试如何运行：
+ `MOCK`（默认）：加载Web `ApplicationContext`并提供一个模拟的Web `Environment`。使用这个注解时不启动嵌入式服务器。Web `Environment`在`classpath`中不可用时，这种模式显然会回落为创建常规的非Web `ApplicationContext`。可以同时使用`@AutoConfigureMockMvc`或`@AutoConfigureWebTestClient`来执行Web应用程序的模拟测试。
+ `RANDOM_PORT`：加载`WebServerApplicationContext`并提供一个真实的Web `Environment`。启动嵌入式服务器并监听定义一个随机端口。
+ `DEFINED_PORT`：加载`WebServerApplicationContext`并提供一个真实的Web `Environment`。启动嵌入式服务器并监听定义的端口（来自`application.properties`）或默认的8080端口。
+ `NONE`：使用`SpringApplication`来加载`ApplicationContext`，但不提供任何Web `Environment`（模拟或其他）。

<univ-note type="note">

测试使用`@Transactional`时，默认情况下，每个测试方法会在结束时回滚事务。然而，这个约定与`RANDOM_PORT`或`DEFINED_PORT`一起使用，隐式提供一个真实的Servlet环境时，HTTP客户端和服务器会运行在单独的线程中，也就是单独的事务中。这种情况下，服务器上开启的任何事务都不会回滚。

</univ-note>

<univ-note type="note">

使用含有`webEnvironment = WebEnvironment.RANDOM_PORT`的`@SpringBootTest`时，如果应用程序为管理服务器使用不同的端口，那也会在一个单独的随机端口上启动管理服务器。

</univ-note>

## 检测Web应用程序类型

Spring MVC可用时，配置常规的基于MVC的应用程序上下文。只包含Spring WebFlux时，检测并配置基于WebFlux的应用程序上下文。

同时包含Spring MVC和Spring WebFlux时，Spring MVC优先。这种情况下，要测试响应式Web应用程序的话，必须设置`spring.main.web-application-type`属性。

```java
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest(properties = "spring.main.web-application-type=reactive")
class MyWebFluxTests {

}
```

## 检测测试配置

熟悉Spring测试框架的话，可能会习惯于使用`@ContextConfiguration(classes=...)`来指定需要加载的Spring `@Configuration`。或者，可能经常会在测试中使用嵌套的`@Configuration`类。

测试Spring Boot应用程序时，这些通常都不需要。未显示定义主配置时，Spring Boot的`@*Test`注解会自动搜索主配置。

搜索算法从包含测试的包开始，直到找到含有`@SpringBootApplication`或`@SpringBootConfiguration`注解的类为止。只要代码组织方式合理，通常都能找到主配置。

<univ-note type="note">

使用测试注解来测试应用程序的具体层面时，应该避免在`main`方法所在的应用程序类上添加特定领域的配置。

`@SpringBootApplication`的底层组件扫描配置定义了排除过滤器，用于确保切片正常工作。在`@SpringBootApplication`注解的类上显式使用`@ComponentScan`指令时，这些排除过滤器将会被禁用。如果使用了切片的话，应该重新定义这些切片。

</univ-note>

要定制主配置时，可以使用一个嵌套的`@TestConfiguration`类。与嵌套的`@Configuration`类不同，嵌套的`@Configuration`类会替代应用程序的主配置，嵌套的`@TestConfiguration`类在应用程序的主配置之外使用。

<univ-note type="note">

Spring的测试框架会在测试之间缓存应用程序上下文。因此，只要测试共享相同配置（无论怎样发现），加载上下文的耗时过程只会发生一次。

</univ-note>

## 排除测试配置

应用程序使用组件扫描（例如，使用`@SpringBootApplication`或`@ComponentScan`）时，可能会发现，为特定测试创建的顶层配置类可以在任何地方使用。

如前面所示，可以在测试的内部类上使用`@TestConfiguration`来定制主配置。放在顶层类上时，`@TestConfiguration`表示`src/test/java`中的类不应该被扫描到。随后，可以在需要的地方显式导入这个类，如下所示：

```java
import org.junit.jupiter.api.Test;

import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;

@SpringBootTest
@Import(MyTestsConfiguration.class)
class MyTests {

    @Test
    void exampleTest() {

    }

}
```

<univ-note type="note">

直接使用`@ComponentScan`（不通过`@SpringBootApplication`）时，需要在`@ComponentScan`中注册`TypeExcludeFilter`。

</univ-note>

## 使用应用程序参数

应用程序需要参数时，`@SpringBootTest`可以使用`args`属性来注入参数。

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.test.context.SpringBootTest;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(args = "--app.test=one")
class MyApplicationArgumentTests {

    @Test
    void applicationArgumentsPopulated(@Autowired ApplicationArguments args) {
        assertThat(args.getOptionNames()).containsOnly("app.test");
        assertThat(args.getOptionValues("app.test")).containsOnly("one");
    }

}
```

## 使用模拟环境进行测试

默认情况下，`@SpringBootTest`不会启动服务器，但是会设置一个模拟环境来测试Web端点。

对于Spring MVC，可以使用`MockMvc`或`WebTestClient`来查询Web端点，如下所示：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.reactive.server.WebTestClient;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@SpringBootTest
@AutoConfigureMockMvc
class MyMockMvcTests {

    @Test
    void testWithMockMvc(@Autowired MockMvc mvc) throws Exception {
        mvc.perform(get("/")).andExpect(status().isOk()).andExpect(content().string("Hello World"));
    }

    // classpath中包含Spring WebFlux时，可以使用WebTestClient来驱动MVC测试
    @Test
    void testWithWebTestClient(@Autowired WebTestClient webClient) {
        webClient.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class).isEqualTo("Hello World");
    }

}
```

<univ-note type="tip">

只想关注Web层面，而不是启动一个完整的`ApplicationContext`，可以使用`@WebMvcTest`。

</univ-note>

对于Spring `WebFlux`端点，可以使用`WebTestClient`，如下所示：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.reactive.server.WebTestClient;

@SpringBootTest
@AutoConfigureWebTestClient
class MyMockWebTestClientTests {

    @Test
    void exampleTest(@Autowired WebTestClient webClient) {
        webClient.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class).isEqualTo("Hello World");
    }

}
```

<univ-note type="tip">

在模拟环境测试通常比使用完整的Servlet容器来运行更快。但是，因为模拟的是Spring MVC层，所以依赖于底层Servlet容器行为的代码不能使用MockMvc来直接进行测试。

例如，Spring Boot的错误处理基于Servlet容器提供的错误页面支持。这意味着，虽然可以测试MVC层，异常抛出和处理也不出所料，但是不能直接测试特定的自定义错误页面是否已经渲染。如果需要测试这些低层次问题，可以启动一个完整运行的服务器。

</univ-note>

## 使用运行服务器进行测试

如果需要启动一个完整运行的服务器，建议使用随机端口。如果使用`@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)`，每次运行测试时，都会随机选择一个可用端口。

`@LocalServerPort`注解可以注入测试中使用的实际端口。为了方便，需要对已启动服务器进行REST调用的测试还可以`@Autowire`一个`WebTestClient`，`WebTestClient`会把相关链接解析到运行服务器，并附带一个用于验证响应的专用API。

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.test.web.reactive.server.WebTestClient;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyRandomPortWebTestClientTests {

    @Test
    void exampleTest(@Autowired WebTestClient webClient) {
        webClient.get().uri("/").exchange().expectStatus().isOk().expectBody(String.class).isEqualTo("Hello World");
    }

}
```

<univ-note type="tip">

`WebTestClient`可用于运行服务器和模拟环境。

</univ-note>

这个设置需要在`classpath`中包含`spring-webflux`。如果不能或不愿添加`webflux`，Spring Boot还提供了`TestRestTemplate`：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.client.TestRestTemplate;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyRandomPortTestRestTemplateTests {

    @Test
    void exampleTest(@Autowired TestRestTemplate restTemplate) {
        String body = restTemplate.getForObject("/", String.class);
        assertThat(body).isEqualTo("Hello World");
    }

}
```

## 定制WebTestClient

需要定制`WebTestClient` Bean的话，可以配置一个`WebTestClientBuilderCustomizer` Bean。这个Bean会调用用于创建`WebTestClient`的`WebTestClient.Builder`。

## 使用JMX

因为测试上下文框架会缓存上下文，因此默认禁用JMX，防止在相同域中注册相同组件。如果测试需要访问`MBeanServer`，可以把测试标记`@DirtiesContext`：

```java
import javax.management.MBeanServer;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.junit.jupiter.SpringExtension;

import static org.assertj.core.api.Assertions.assertThat;

@ExtendWith(SpringExtension.class)
@SpringBootTest(properties = "spring.jmx.enabled=true")
@DirtiesContext
class MyJmxTests {

    @Autowired
    private MBeanServer mBeanServer;

    @Test
    void exampleTest() {
        assertThat(this.mBeanServer.getDomains()).contains("java.lang");
    }

}
```

## 使用指标

无论`classpath`如何，使用`@SpringBootTest`时，不会自动配置计量器注册表，内存中支持的计量器注册表除外。

需要把指标导出到不同的后端，作为集成测试的一部分时，可以在测试上使用`@AutoConfigureMetrics`注解。

## 模拟和监视Bean

运行测试时，有时候需要模拟应用程序上下文中的某些组件。例如，可能存在一些开发期间不能使用的远程服务。需要模仿真实环境中难以触发的故障时，模拟也非常有用。

Spring Boot包含一个`@MockBean`注解，可以用于给`ApplicationContext`中的Bean定义一个Mockito模拟。可以使用这个注解来添加一个新的Bean或者替换一个现有的Bean定义。这个注解可以在测试类、测试类的成员变量、`@Configuration`类及其成员变量上直接使用。在成员变量上使用这个注解时，创建的模拟实例也会被注入。每个测试方法结束后，模拟Bean会被自动重置。

<univ-note type="note">

如果测试使用了Spring Boot的其中一个测试注解（例如`@SpringBootTest`），那么就会自动启用这个特性。需要用不同方式来使用这个特性时，必须显式添加监听器，如下所示：

```java
import org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener;
import org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;

@ContextConfiguration(classes = MyConfig.class)
@TestExecutionListeners({ MockitoTestExecutionListener.class, ResetMocksTestExecutionListener.class })
class MyTests {

}
```

</univ-note>

以下示例使用模拟实现来替换现有的`RemoteService` Bean：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.BDDMockito.given;

@SpringBootTest
class MyTests {

    @Autowired
    private Reverser reverser;

    @MockBean
    private RemoteService remoteService;

    @Test
    void exampleTest() {
        given(this.remoteService.getValue()).willReturn("spring");
        String reverse = this.reverser.getReverseValue(); // 调用注入的RemoteService
        assertThat(reverse).isEqualTo("gnirps");
    }

}
```

<univ-note type="note">

`@MockBean`不能用于模拟应用程序上下文刷新期间执行的Bean行为。测试执行时，应用程序上下文的刷新已经完成，这时候配置模拟行为已经太迟了。这种情况下，建议使用一个`@Bean`方法来创建和配置模拟。

</univ-note>

此外，可以使用`@SpyBean`，通过Mockito监视器来包装现有的Bean。

<univ-note type="note">

CGLib代理，比如为作用域Bean创建的代理，会把代理方法声明为`final`。这会阻碍Mockito的正常工作，因为默认配置中，Mockito不能模拟或监视`final`方法。如果需要模拟或监视这样的Bean，在应用程序的测试依赖中添加`org.mockito:mockito-inline`，可以配置Mockito使用其内联模拟生成器。这样Mockito就可以模拟和监视`final`方法。

</univ-note>

<univ-note type="note">

Spring的测试框架会在测试之间缓存应用程序上下文，并且会为共享相同配置的测试重用上下文，`@MockBean`或`@SpyBean`的使用会影响缓存Key，很有可能会增加上下文的数量。

</univ-note>

<univ-note type="tip">

使用`@SpyBean`来监视一个含有`@Cacheable`方法（通过名称来引用参数）的Bean时，应用程序必须使用`-parameters`来进行编译。这可以确保Bean一旦被监视时，缓存设施就可以使用参数名。

</univ-note>

<univ-note type="tip">

在Spring代理的Bean上使用`@SpyBean`来监视时，某些情况下可能需要移除Spring的代理，例如，使用`given`或`when`来设置期望值时，可以使用`AopTestUtils.getTargetObject(yourProxiedSpy)`。

</univ-note>

## 自动配置的Test

对应用程序而言，Spring Boot的自动配置系统工作得很好，但是有时候对测试而言有点过多。通常，只加载应用程序的部分测试所需的配置是非常有帮助的。例如，测试Spring MVC控制器是否正确地映射URL时，并不需要涉及数据库调用；或者，测试JPA实体时，并不关注Web层。

`spring-boot-test-autoconfigure`模块包含了许多注解，可以用于自动配置所需的配置。这些注解的使用方式类似，提供一个`@...Test`注解，用于加载`ApplicationContext`，提供一个或多个`@AutoConfigure...`注解，用于定制自动配置。

<univ-note type="note">

每个切片都限制了组件扫描时只扫描合适的组件，并加载一组非常有限的自动配置类。如果需要排除其中一个，大多数`@...Test`注解都提供了`excludeAutoConfiguration`属性。或者，也可以使用`@ImportAutoConfiguration#exclude`。

</univ-note>

<univ-note type="note">

不能在一个测试中使用多个`@...Test`注解来引入多个切片。需要多个切片时，选择其中一个`@...Test`注解，手动引入其他切片的`@AutoConfigure...`注解。

</univ-note>

<univ-note type="tip">

也可以一起使用`@AutoConfigure...`注解和标准的`@SpringBootTest`注解。如果对应用程序切片不感兴趣，但是又需要一些自动配置的测试Bean时，可以使用这种组合。

</univ-note>

## 自动配置的JsonTest

要测试对象的JSON序列化和反序列化是否符合预期，可以使用`@JsonTest`注解。`@JsonTest`自动配置了可用的JSON映射器，可以是以下库之一：
+ `Jackson`的`ObjectMapper`，任何`@JsonComponent` Bean和`Jackson`模块。
+ `Gson`
+ `Jsonb`

<univ-note type="note">

`@JsonTest`启用的自动配置列表可以参考附录。

</univ-note>

如果需要配置自动配置元素，可以使用`@AutoConfigureJsonTesters`注解。

Spring Boot包含了基于AssertJ的，与JSONAssert和JsonPath库一起使用的帮助类，用于检查JSON的显示是否符合预期。`JacksonTester`、`GsonTester`、`JsonbTester`和`BasicJsonTester`类可分别用于Jackson、Gson、Jsonb和String。使用`@JsonTest`时，测试类上的任何帮助字段都可以`@Autowired`。以下示例为一个Jackson的测试类：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.json.JsonTest;
import org.springframework.boot.test.json.JacksonTester;

import static org.assertj.core.api.Assertions.assertThat;

@JsonTest
class MyJsonTests {

    @Autowired
    private JacksonTester<VehicleDetails> json;

    @Test
    void serialize() throws Exception {
        VehicleDetails details = new VehicleDetails("Honda", "Civic");
        // 对与测试相同包中的.json文件进行断言
        assertThat(this.json.write(details)).isEqualToJson("expected.json");
        // 使用JSON路径断言
        assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
        assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make").isEqualTo("Honda");
    }

    @Test
    void deserialize() throws Exception {
        String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
        assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails("Ford", "Focus"));
        assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
    }

}
```

<univ-note type="note">

JSON帮助类也可以在标准单元测试中直接使用。要实现这一点，又不使用`@JsonTest`的话，可以在`@Before`方法中调用帮助类的`initFields`方法。

</univ-note>

使用Spring Boot的基于AssertJ的帮助类来断言给定JSON路径上的数字值，可能不能使用`isEqualTo`，这取决于类型。相反，可以使用AssertJ的`satisfies`来断言值是否匹配给定条件。例如，以下示例断言实际数值是一个接近`0.15`，偏移量在`0.01`之内的浮点数。

```java
@Test
void someTest() throws Exception {
    SomeObject value = new SomeObject(0.152f);
    assertThat(this.json.write(value)).extractingJsonPathNumberValue("@.test.numberValue").satisfies((number) -> assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f)));
}
```

## 自动配置的WebMvcTest

要测试Spring MVC控制器的工作是否符合预期，可以使用`@WebMvcTest`注解。`@WebMvcTest`自动配置了Spring MVC设施，并把扫描的Bean限制为：`@Controller`、`@ControllerAdvice`、`@JsonComponent`、`Converter`、`GenericConverter`、`Filter`、`HandlerInterceptor`、`WebMvcConfigurer`、`WebMvcRegistrations`和`HandlerMethodArgumentResolver`。使用`@WebMvcTest`注解时，不会扫描常规的`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可以用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@WebMvcTest`启用的自动配置列表可以参考附录。

</univ-note>

<univ-note type="tip">

如果需要注册其他组件，例如，Jackson模块，可以在测试中使用`@Import`来引入其他配置类。

</univ-note>

通常，`@WebMvcTest`仅限于单个控制器，并与`@MockBean`注解一起使用，为需要的合作者提供模拟实现。

`@WebMvcTest`会自动配置`MockMvc`。`MockMvc`提供了一种强大的方式来快速测试MVC控制器，而不需要启动完整的HTTP服务器。

<univ-note type="tip">

使用`@AutoConfigureMockMvc`注解，可以在非`@WebMvcTest`（例如`@SpringBootTest`）中自动配置`MockMvc`。以下示例使用`MockMvc`：

</univ-note>

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.mockito.BDDMockito.given;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(UserVehicleController.class)
class MyControllerTests {

    @Autowired
    private MockMvc mvc;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot")).willReturn(new VehicleDetails("Honda", "Civic"));
        this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN)).andExpect(status().isOk()).andExpect(content().string("Honda Civic"));
    }

}
```

<univ-note type="tip">

如果需要自动配置的配置元素（例如，应该应用Servlet过滤器时），可以使用`@AutoConfigureMockMvc`注解的属性。

</univ-note>

如果使用HtmlUnit和Selenium，自动配置提供了一个HtmlUnit的`WebClient` Bean和一个Selenium的`WebDriver` Bean。以下示例使用HtmlUnit：

```java
import com.gargoylesoftware.htmlunit.WebClient;
import com.gargoylesoftware.htmlunit.html.HtmlPage;
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.BDDMockito.given;

@WebMvcTest(UserVehicleController.class)
class MyHtmlUnitTests {

    @Autowired
    private WebClient webClient;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot")).willReturn(new VehicleDetails("Honda", "Civic"));
        HtmlPage page = this.webClient.getPage("/sboot/vehicle.html");
        assertThat(page.getBody().getTextContent()).isEqualTo("Honda Civic");
    }

}
```

<univ-note type="note">

默认情况下，Spring Boot会把`WebDriver` Bean放在一个特殊的作用域中，确保每次测试后都会退出`WebDriver`，并在每次测试时都会注入一个新的实例。如果不想要这个行为，可以给`WebDriver @Bean`定义添加`@Scope("singleton")`。

</univ-note>

<univ-note type="warn">

Spring Boot创建的`webDriver`作用域会替代用户定义的同名作用域。如果定义了自己的`webDriver`作用域，使用`@WebMvcTest`时，可能会发现这个作用域已经停止了工作。

</univ-note>

如果`classpath`含有Spring Security，`@WebMvcTest`也会扫描`WebSecurityConfigurer` Bean。为了在这类测试中不会完全禁用Spring Security，可以使用Spring Security的测试支持。关于如何使用Spring Security的`MockMvc`支持的更多细节，可以参考`使用Spring Security进行测试`章节。

<univ-note type="tip">

有时候编写Spring MVC测试并不够，Spring Boot可以运行完整的，实际服务器的端对端测试。

</univ-note>

## 自动配置的WebFluxTest

要测试Spring WebFlux控制器的工作是否符合预期，可以使用`@WebFluxTest`注解。`@WebFluxTest`自动配置了Spring WebFlux，并把扫描的Bean限制为：`@Controller`、`@ControllerAdvice`、`@JsonComponent`、`Converter`、`GenericConverter`、`WebFilter`和`WebFluxConfigurer`。使用`@WebFluxTest`注解时，不会扫描`@Component`和` @ConfigurationProperties` Bean。`@EnableConfigurationProperties`可以用于引入`@ConfigurationProperties` Bean。

<univ-note type="note">

`@WebFluxTest`启用的自动配置列表可以参考附录。

</univ-note>


<univ-note type="note">

如果需要注册其他组件，例如，Jackson模块，可以在测试中使用`@Import`来引入其他配置类。

</univ-note>

通常，`@WebFluxTest`仅限于单个控制器，并与`@MockBean`注解一起使用，为需要的合作者提供模拟实现。

`@WebFluxTest`会自动配置`WebTestClient`。`WebTestClient`提供了一种强大的方式来快速测试WebFlux控制器，而不需要启动完整的HTTP服务器。

<univ-note type="note">

使用`@AutoConfigureWebTestClient`注解，可以在非`@WebFluxTest`（例如`@SpringBootTest`）中自动配置`WebTestClient`。以下示例使用了`@WebFluxTest`和`WebTestClient`：

</univ-note>

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.reactive.server.WebTestClient;

import static org.mockito.BDDMockito.given;

@WebFluxTest(UserVehicleController.class)
class MyControllerTests {

    @Autowired
    private WebTestClient webClient;

    @MockBean
    private UserVehicleService userVehicleService;

    @Test
    void testExample() {
        given(this.userVehicleService.getVehicleDetails("sboot")).willReturn(new VehicleDetails("Honda", "Civic"));
        this.webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN).exchange().expectStatus().isOk().expectBody(String.class).isEqualTo("Honda Civic");
    }

}
```

<univ-note type="tip">

这个设置仅有WebFlux应用程序支持，因为目前在模拟的Web应用程序中使用的`WebTestClient`只能与WebFlux一起使用。

</univ-note>

<univ-note type="note">

`@WebFluxTest`无法检测通过函数式Web框架注册的路由。要测试上下文中的`RouterFunction` Bean，可以使用`@Import`或`@SpringBootTest`来引入`RouterFunction`。

</univ-note>

<univ-note type="note">

`@WebFluxTest`无法检测注册为`SecurityWebFilterChain`类型的`@Bean`的自定义安全配置。要在测试中引入这些，可以使用`@Import`或`@SpringBootTest`来引入注册这些Bean的配置。

</univ-note>

<univ-note type="tip">

有时候编写Spring WebFlux测试并不够，Spring Boot可以运行完整的，实际服务器的端对端测试。

</univ-note>

## 自动配置的GraphQlTest

Spring GraphQL提供了专用的测试支持模块，需要把这个模块添加到项目中：

+ Maven

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.graphql</groupId>
        <artifactId>spring-graphql-test</artifactId>
        <scope>test</scope>
    </dependency>
    <!-- 除非compile作用域中已经存在 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

+ Gradle

```gradle
dependencies {
    testImplementation("org.springframework.graphql:spring-graphql-test")
    // 除非implementation配置中已经存在
    testImplementation("org.springframework.boot:spring-boot-starter-webflux")
}
```

这个测试模块提供了`GraphQlTester`。`GraphQlTester`在测试中大量使用，所以必须熟悉`GraphQlTester`的使用。存在一些`GraphQlTester`变体，Spring Boot会根据测试类型来自动配置这些变体：
+ `ExecutionGraphQlServiceTester`：在服务端执行测试，没有客户端及传输工具。
+ `HttpGraphQlTester`：使用连接到服务器的客户端来执行测试，存在或不存在运行着的服务器。

Spring Boot通过`@GraphQlTest`注解来帮助测试Spring GraphQL控制器。`@GraphQlTest`自动配置了Spring GraphQL，不涉及任何传输工具或服务器。扫描的Bean被限制为：`@Controller`、`RuntimeWiringConfigurer`、`JsonComponent`、`Converter`、`GenericConverter`、`DataFetcherExceptionResolver`、`Instrumentation`和`GraphQlSourceBuilderCustomizer`。使用`@GraphQlTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@GraphQlTest`启用的自动配置列表可以参考附录。

</univ-note>

<univ-note type="tip">

如果需要注册其他组件，例如，Jackson模块，可以在测试中使用`@Import`来引入其他配置类。

</univ-note>

通常，`@GraphQlTest`仅限于一组控制器，并与`@MockBean`注解一起使用，为需要的合作者提供模拟实现。

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.docs.web.graphql.runtimewiring.GreetingController;
import org.springframework.boot.test.autoconfigure.graphql.GraphQlTest;
import org.springframework.graphql.test.tester.GraphQlTester;

@GraphQlTest(GreetingController.class)
class GreetingControllerTests {

    @Autowired
    private GraphQlTester graphQlTester;

    @Test
    void shouldGreetWithSpecificName() {
        this.graphQlTester.document("{ greeting(name: \"Alice\") } ").execute().path("greeting").entity(String.class).isEqualTo("Hello, Alice!");
    }

    @Test
    void shouldGreetWithDefaultName() {
        this.graphQlTester.document("{ greeting } ").execute().path("greeting").entity(String.class).isEqualTo("Hello, Spring!");
    }

}
```

`@SpringBootTest`测试时完整的集成测试，涉及整个应用程序。使用随机或指定端口时，会配置运行的服务器，并自动发布一个可用于测试服务器的`HttpGraphQlTester` Bean。配置模拟环境时，在测试类上使用`@AutoConfigureHttpGraphQlTester`注解，也可以请求`HttpGraphQlTester` Bean。

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.graphql.tester.AutoConfigureHttpGraphQlTester;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.graphql.test.tester.HttpGraphQlTester;

@AutoConfigureHttpGraphQlTester
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
class GraphQlIntegrationTests {

    @Test
    void shouldGreetWithSpecificName(@Autowired HttpGraphQlTester graphQlTester) {
        HttpGraphQlTester authenticatedTester = graphQlTester.mutate().webTestClient((client) -> client.defaultHeaders((headers) -> headers.setBasicAuth("admin", "ilovespring"))).build();
        authenticatedTester.document("{ greeting(name: \"Alice\") } ").execute().path("greeting").entity(String.class).isEqualTo("Hello, Alice!");
    }

}
```

## 自动配置的DataCassandraTest

可以使用`@DataCassandraTest`来测试Cassandra应用程序。默认情况下，`@DataCassandraTest`会配置一个`CassandraTemplate`，扫描`@Table`类，并配置Spring Data Cassandra Repository。使用`@DataCassandraTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataCassandraTest`启用的自动配置列表可以参考附录。

</univ-note>

以下示例为Spring Boot中使用Cassandra测试的典型设置：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.cassandra.DataCassandraTest;

@DataCassandraTest
class MyDataCassandraTests {

    @Autowired
    private SomeRepository repository;

}
```

## 自动配置的DataCouchbaseTest

可以使用`@DataCouchbaseTest`来测试Couchbase应用程序。默认情况下，`@DataCouchbaseTest`会配置一个`CouchbaseTemplate`或`ReactiveCouchbaseTemplate`，扫描`@Document`类，并配置Spring Data Couchbase Repository。使用`@DataCouchbaseTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataCouchbaseTest`启用的自动配置列表可以参考附录。

</univ-note>

以下示例为Spring Boot中使用Couchbase测试的典型设置：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.couchbase.DataCouchbaseTest;

@DataCouchbaseTest
class MyDataCouchbaseTests {

    @Autowired
    private SomeRepository repository;

}
```

## 自动配置的DataElasticsearchTest

可以使用`@DataElasticsearchTest`来测试Elasticsearch应用程序。默认情况下，`@DataElasticsearchTest`会配置一个`ElasticsearchRestTemplate`，扫描`@Document`类，并配置Spring Data Elasticsearch Repository。使用`@DataElasticsearchTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataElasticsearchTest`启用的自动配置列表可以参考附录。

</univ-note>

以下示例为Spring Boot中使用Elasticsearch测试的典型设置：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.elasticsearch.DataElasticsearchTest;

@DataElasticsearchTest
class MyDataElasticsearchTests {

    @Autowired
    private SomeRepository repository;

}
```

## 自动配置的DataJpaTest

可以使用`@DataJpaTest`注解来测试JPA应用程序。默认情况下，`@DataJpaTest`会扫描`@Entity`类，并配置Spring Data JPA Repository。`@DataJpaTest`也会配置`classpath`中可用的嵌入式数据库。把`spring.jpa.show-sql`属性设置为`true`，默认会记录SQL查询日志。可以使用`@DataJpaTest`注解的`showSql()`属性来禁用SQL查询日志。

使用`@DataJpaTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataJpaTest`启用的自动配置列表可以参考附录。

</univ-note>

默认情况下，`@DataJpaTest`是事务性的，在每个测试结束时会回滚。如果不想要这个特性，可以为某个测试或整个类禁用事务管理，如下所示：

```java
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@DataJpaTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class MyNonTransactionalTests {

}
```

JPA测试也可以注入一个`TestEntityManager` Bean，这个Bean用于替代JPA的标准`EntityManager`，时专门为测试设计的。

<univ-note type="tip">

通过添加`@AutoConfigureTestEntityManager`注解，`TestEntityManager`也可以自动配置到基于Spring的任何测试类。需要这样做时，必须在事务中运行测试，例如，在测试类或方法上添加`@Transactional`注解。

</univ-note>

如果需要的话，还可以使用`JdbcTemplate`。以下示例为`@DataJpaTest`注解的使用：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;

import static org.assertj.core.api.Assertions.assertThat;

@DataJpaTest
class MyRepositoryTests {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private UserRepository repository;

    @Test
    void testExample() {
        this.entityManager.persist(new User("sboot", "1234"));
        User user = this.repository.findByUsername("sboot");
        assertThat(user.getUsername()).isEqualTo("sboot");
        assertThat(user.getEmployeeNumber()).isEqualTo("1234");
    }

}
```

嵌入式内存数据库通常可以很好地应用于测试，因为这种数据库很快，并且不需要安装。如果需要在真实数据库上运行测试，可以使用`@AutoConfigureTestDatabase`注解。如下所示：

```java
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;

@DataJpaTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
class MyRepositoryTests {

}
```

## 自动配置的JdbcTest

`@JdbcTest`类似于`@DataJpaTest`，但是，`@JdbcTest`适用于只需要`DataSource`，不使用Spring Data JDBC的测试。默认情况下，`@JdbcTest`会配置一个嵌入式内存数据库和一个`JdbcTemplate`。使用`@JdbcTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@JdbcTest`启用的自动配置列表可以参考附录。

</univ-note>

默认情况下，`@JdbcTest`是事务性的，在每个测试结束时会回滚。如果不想要这个特性，可以为某个测试或整个类禁用事务管理，如下所示：

```java
import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@JdbcTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class MyTransactionalTests {

}
```

如果需要在真实数据库上运行测试，可以使用`@AutoConfigureTestDatabase`注解，使用方式与`@DataJpaTest`一样。

## 自动配置的DataJdbcTest

`@DataJdbcTest`类似于`@JdbcTest`，但是，`@DataJdbcTest`适用于使用Spring Data JDBC的测试。默认情况下，`@DataJdbcTest`会配置一个嵌入式内存数据库，一个`JdbcTemplate`，以及Spring Data JDBC Repository。使用`@DataJdbcTest`注解时，只会扫描`AbstractJdbcConfiguration`的子类，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataJdbcTest`启用的自动配置列表可以参考附录。

</univ-note>

默认情况下，`@DataJdbcTest`是事务性的，在每个测试结束时会回滚。如果不想要这个特性，可以为某个测试或整个类禁用事务管理。

如果需要在真实数据库上运行测试，可以使用`@AutoConfigureTestDatabase`注解，使用方式与`@DataJpaTest`一样。

## 自动配置的JooqTest

`@JooqTest`的使用方式类似于`@JdbcTest`，但是，`@JooqTest`适用于jOOQ相关的测试。因为jOOQ严重依赖与数据库Schema相对应的基于Java的Schema，因为会使用现有的`DataSource`。如果想用内存数据库来替代`DataSource`，可以使用`@AutoConfigureTestDatabase`来覆盖那些设置。使用`@JooqTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@JooqTest`启用的自动配置列表可以参考附录。

</univ-note>

`@JooqTest`会配置一个`DSLContext`。以下示例为`@JooqTest`注解的使用：

```java
import org.jooq.DSLContext;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.jooq.JooqTest;

@JooqTest
class MyJooqTests {

    @Autowired
    private DSLContext dslContext;

}
```

默认情况下，`@JooqTest`是事务性的，在每个测试结束时会回滚。如果不想要这个特性，可以为某个测试或整个类禁用事务管理。

## 自动配置的DataMongoTest

可以使用`@DataMongoTest`来测试MongoDB应用程序。默认情况下，`@DataMongoTest`会配置一个嵌入式内存MongoDB（如果可用的话），配置一个`MongoTemplate`，扫描`@Document`类，并配置Spring Data MongoDB Repository。使用`@DataMongoTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataMongoTest`启用的自动配置列表可以参考附录。

</univ-note>

以下为`@DataMongoTest`注解的使用示例：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
import org.springframework.data.mongodb.core.MongoTemplate;

@DataMongoTest
class MyDataMongoDbTests {

    @Autowired
    private MongoTemplate mongoTemplate;

}
```

嵌入式内存MongoDB通常可以很好地应用于测试，因为这种MongoDB很快，并且不需要安装。如果需要在真实的MongoDB服务器上运行测试，需要排除嵌入式MongoDB的自动配置。如下所示：

```java
import org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;
import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;

@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)
class MyDataMongoDbTests {

}
```

## 自动配置的DataNeo4jTest

可以使用`@DataNeo4jTest`来测试Neo4j应用程序。默认情况下，`@DataNeo4jTest`会扫描`@Node`类，并配置Spring Data Neo4j Repository。使用`@DataNeo4jTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataNeo4jTest`启用的自动配置列表可以参考附录。

</univ-note>

以下为Spring Boot中使用`@DataNeo4jTest`注解的典型设置示例：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;

@DataNeo4jTest
class MyDataNeo4jTests {

    @Autowired
    private SomeRepository repository;

}
```

默认情况下，`@DataNeo4jTest`是事务性的，在每个测试结束时会回滚。如果不想要这个特性，可以为某个测试或整个类禁用事务管理，如下所示：

```java
import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

@DataNeo4jTest
@Transactional(propagation = Propagation.NOT_SUPPORTED)
class MyDataNeo4jTests {

}
```

响应式访问不支持事务性测试。如果使用这种方式，必须配置`@DataNeo4jTest`测试，如上所示。

## 自动配置的DataRedisTest

可以使用`@DataRedisTest`来测试Redis应用程序。默认情况下，`@DataRedisTest`会扫描`@RedisHash`类，并配置Spring Data Redis Repository。使用`@DataRedisTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataRedisTest`启用的自动配置列表可以参考附录。

</univ-note>

以下为`@DataRedisTest`注解的使用示例：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;

@DataRedisTest
class MyDataRedisTests {

    @Autowired
    private SomeRepository repository;

}
```

## 自动配置的DataLdapTest

可以使用`@DataLdapTest`来测试LDAP应用程序。默认情况下，`@DataLdapTest`会配置一个嵌入式内存LDAP（如果可用的话），配置一个`LdapTemplate`，扫描`@Entry`类，并配置Spring Data LDAP Repository。使用`@DataLdapTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@DataLdapTest`启用的自动配置列表可以参考附录。

</univ-note>

以下为`@DataLdapTest`注解的使用示例：

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
import org.springframework.ldap.core.LdapTemplate;

@DataLdapTest
class MyDataLdapTests {

    @Autowired
    private LdapTemplate ldapTemplate;

}
```

嵌入式内存LDAP通常可以很好地应用于测试，因为这种LDAP很快，并且不需要安装。如果需要在真实的LDAP服务器上运行测试，需要排除嵌入式LDAP的自动配置。如下所示：

```java
import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;
import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;

@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
class MyDataLdapTests {

}
```

## 自动配置的RestClientTest

可以使用`@RestClientTest`来测试REST Client。默认情况下，`@RestClientTest`会配置Jackson、GSON和Jsonb支持，配置一个`RestTemplateBuilder`，并为`MockRestServiceServer`添加支持。使用`@RestClientTest`注解时，不会扫描`@Component`和`@ConfigurationProperties` Bean。`@EnableConfigurationProperties`可用于引入`@ConfigurationProperties` Bean。

<univ-note type="tip">

`@RestClientTest`启用的自动配置列表可以参考附录。

</univ-note>

要测试的特定Bean，应该使用`@RestClientTest`的`value`或`components`属性来指定。如下所示：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.client.RestClientTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.client.MockRestServiceServer;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess;

@RestClientTest(RemoteVehicleDetailsService.class)
class MyRestClientTests {

    @Autowired
    private RemoteVehicleDetailsService service;

    @Autowired
    private MockRestServiceServer server;

    @Test
    void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() {
        this.server.expect(requestTo("/greet/details")).andRespond(withSuccess("hello", MediaType.TEXT_PLAIN));
        String greeting = this.service.callRestService();
        assertThat(greeting).isEqualTo("hello");
    }

}
```

## 自动配置的AutoConfigureRestDocs

通过`@AutoConfigureRestDocs`注解，可以在测试中使用Spring REST Docs及Mock MVC、REST Assured或WebTestClient。`@AutoConfigureRestDocs`消除了Spring REST Docs对JUnit扩展的需求。

`@AutoConfigureRestDocs`可以用于覆盖默认输出目录（使用Maven时是`target/generated-snippets`，使用Gradle时是`build/generated-snippets`）。`@AutoConfigureRestDocs`也可以用于配置任何文档URI中出现的host、scheme、port。

### 自动配置的AutoConfigureRestDocs和MockMvc

为了在测试基于Servlet的Web应用程序时，可以使用Spring REST Docs，`@AutoConfigureRestDocs`定制了`MockMvc` Bean。 

可以使用`@Autowired`来注入`MockMvc`，并在测试中使用`MockMvc`，跟正常使用Mock MVC和Spring REST Docs时一样，如下所示：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest(UserController.class)
@AutoConfigureRestDocs
class MyUserDocumentationTests {

    @Autowired
    private MockMvc mvc;

    @Test
    void listUsers() throws Exception {
        this.mvc.perform(get("/users").accept(MediaType.TEXT_PLAIN)).andExpect(status().isOk()).andDo(document("list-users"));
    }

}
```

如果需要更多地控制Spring REST Docs的配置，而不是使用`@AutoConfigureRestDocs`的属性提供的配置，可以使用`RestDocsMockMvcConfigurationCustomizer` Bean，如下所示：

```java
import org.springframework.boot.test.autoconfigure.restdocs.RestDocsMockMvcConfigurationCustomizer;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.restdocs.mockmvc.MockMvcRestDocumentationConfigurer;
import org.springframework.restdocs.templates.TemplateFormats;

@TestConfiguration(proxyBeanMethods = false)
public class MyRestDocsConfiguration implements RestDocsMockMvcConfigurationCustomizer {

    @Override
    public void customize(MockMvcRestDocumentationConfigurer configurer) {
        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
    }

}
```

如果想要使用Spring REST Docs对参数化输出目录的支持，可以创建一个`RestDocumentationResultHandler` Bean。自动配置会使用这个处理器来调用`alwaysDo`，因此，每个`MockMvc`调用都会自动生成默认代码片段。如下为`RestDocumentationResultHandler`的定义示例：

```java
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation;
import org.springframework.restdocs.mockmvc.RestDocumentationResultHandler;

@TestConfiguration(proxyBeanMethods = false)
public class MyResultHandlerConfiguration {

    @Bean
    public RestDocumentationResultHandler restDocumentation() {
        return MockMvcRestDocumentation.document("{method-name}");
    }

}
```

### 自动配置的AutoConfigureRestDocs和WebTestClient

可以同时使用`@AutoConfigureRestDocs`和`WebTestClient`来测试响应式Web应用程序。可以使用`@Autowired`来注入`WebTestClient`，并在测试中使用`WebTestClient`，跟正常使用`@WebFluxTest`和Spring REST Docs时一样，如下所示：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
import org.springframework.test.web.reactive.server.WebTestClient;

import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document;

@WebFluxTest
@AutoConfigureRestDocs
class MyUsersDocumentationTests {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    void listUsers() {
        this.webTestClient.get().uri("/").exchange().expectStatus().isOk().expectBody().consumeWith(document("list-users"));
    }

}
```

如果需要更多地控制Spring REST Docs的配置，而不是使用`@AutoConfigureRestDocs`的属性提供的配置，可以使用`RestDocsWebTestClientConfigurationCustomizer` Bean，如下所示：

```java
import org.springframework.boot.test.autoconfigure.restdocs.RestDocsWebTestClientConfigurationCustomizer;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentationConfigurer;

@TestConfiguration(proxyBeanMethods = false)
public class MyRestDocsConfiguration implements RestDocsWebTestClientConfigurationCustomizer {

    @Override
    public void customize(WebTestClientRestDocumentationConfigurer configurer) {
        configurer.snippets().withEncoding("UTF-8");
    }

}
```

如果想要使用Spring REST Docs对参数化输出目录的支持，可以使用一个`WebTestClientBuilderCustomizer`来给每个实体的交换结果配置一个消费者。以下为`WebTestClientBuilderCustomizer`的定义示例：

```java
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.boot.test.web.reactive.server.WebTestClientBuilderCustomizer;
import org.springframework.context.annotation.Bean;

import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document;

@TestConfiguration(proxyBeanMethods = false)
public class MyWebTestClientBuilderCustomizerConfiguration {

    @Bean
    public WebTestClientBuilderCustomizer restDocumentation() {
        return (builder) -> builder.entityExchangeResultConsumer(document("{method-name}"));
    }

}
```

### 自动配置的AutoConfigureRestDocs和RequestSpecification

`@AutoConfigureRestDocs`生成了一个`RequestSpecification` Bean，预配置为使用Spring REST Docs，可用于测试。可以使用`@Autowired`来注入`RequestSpecification`，并在测试中使用`RequestSpecification`，跟正常使用`RequestSpecification`和Spring REST Docs时一样，如下所示：

```java
import io.restassured.specification.RequestSpecification;
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.server.LocalServerPort;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.is;
import static org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureRestDocs
class MyUserDocumentationTests {

    @Test
    void listUsers(@Autowired RequestSpecification documentationSpec, @LocalServerPort int port) {
        given(documentationSpec).filter(document("list-users")).when().port(port).get("/").then().assertThat().statusCode(is(200));
    }

}
```

如果需要更多地控制Spring REST Docs的配置，而不是使用`@AutoConfigureRestDocs`的属性提供的配置，
可以使用`RestDocsRestAssuredConfigurationCustomizer` Bean，如下所示：

```java
import org.springframework.boot.test.autoconfigure.restdocs.RestDocsRestAssuredConfigurationCustomizer;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.restdocs.restassured3.RestAssuredRestDocumentationConfigurer;
import org.springframework.restdocs.templates.TemplateFormats;

@TestConfiguration(proxyBeanMethods = false)
public class MyRestDocsConfiguration implements RestDocsRestAssuredConfigurationCustomizer {

    @Override
    public void customize(RestAssuredRestDocumentationConfigurer configurer) {
        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
    }

}
```

## 自动配置的WebServiceTest

### 自动配置的WebServiceClientTest

可以使用`@WebServiceClientTest`来测试使用Spring Web Services项目来调用Web Services的应用程序。默认情况下，`@WebServiceClientTest`会配置一个模拟的`WebServiceServer` Bean，并自动定制`WebServiceTemplateBuilder`。

<univ-note type="tip">

`@WebServiceClientTest`启用的自动配置列表可以参考附录。

</univ-note>

以下为`@WebServiceClientTest`注解的使用示例：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.webservices.client.WebServiceClientTest;
import org.springframework.ws.test.client.MockWebServiceServer;
import org.springframework.xml.transform.StringSource;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.ws.test.client.RequestMatchers.payload;
import static org.springframework.ws.test.client.ResponseCreators.withPayload;

@WebServiceClientTest(SomeWebService.class)
class MyWebServiceClientTests {

    @Autowired
    private MockWebServiceServer server;

    @Autowired
    private SomeWebService someWebService;

    @Test
    void mockServerCall() {
        this.server.expect(payload(new StringSource("<request/>"))).andRespond(withPayload(new StringSource("<response><status>200</status></response>")));
        assertThat(this.someWebService.test()).extracting(Response::getStatus).isEqualTo(200);
    }

}
```

### 自动配置的WebServiceServerTest

可以使用`@WebServiceServerTest`来测试使用Spring Web Services项目来实现Web Services的应用程序。默认情况下，`@WebServiceServerTest`会配置一个模拟的`MockWebServiceClient` Bean，可用于调用Web Services端点。

<univ-note type="tip">

`@WebServiceServerTest`启用的自动配置列表可以参考附录。

</univ-note>

以下为`@WebServiceServerTest`注解的使用示例：

```java
import org.junit.jupiter.api.Test;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.webservices.server.WebServiceServerTest;
import org.springframework.ws.test.server.MockWebServiceClient;
import org.springframework.ws.test.server.RequestCreators;
import org.springframework.ws.test.server.ResponseMatchers;
import org.springframework.xml.transform.StringSource;

@WebServiceServerTest(ExampleEndpoint.class)
class MyWebServiceServerTests {

    @Autowired
    private MockWebServiceClient client;

    @Test
    void mockServerCall() {
        this.client.sendRequest(RequestCreators.withPayload(new StringSource("<ExampleRequest/>"))).andExpect(ResponseMatchers.payload(new StringSource("<ExampleResponse>42</ExampleResponse>")));
    }

}
```

## 其他自动配置和切片

每个切片提供了一个或多个`@AutoConfigure...`注解，这些注解定义了切片应该引入的自动配置。通过创建自定义`@AutoConfigure...`注解或在测试中添加`@ImportAutoConfiguration`，可以在测试中添加其他自动配置。如下所示：

```java
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration;
import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;

@JdbcTest
@ImportAutoConfiguration(IntegrationAutoConfiguration.class)
class MyJdbcTests {

}
```

<univ-note type="note">

确保不要使用常规的`@Import`注解来引入自动配置，因为Spring Boot会以特殊的方式来处理自动配置。

</univ-note>

此外，通过`META-INF/spring`目录中存储的文件注册的其他自动配置，可以添加到任何切片注解。如下所示：

`META-INF/spring/org.springframework.boot.test.autoconfigure.jdbc.JdbcTest.imports`

```none
com.example.IntegrationAutoConfiguration
```

这个示例中，使用`@JdbcTest`注解的所有测试都会启用`com.example.IntegrationAutoConfiguration`。

<univ-note type="tip">

这个文件中可以使用`#`来进行注释。

</univ-note>

<univ-note type="tip">

使用`@ImportAutoConfiguration`注解，可以定制一个切片或`@AutoConfigure...`注解。

</univ-note>

## 用户自动配置和切片

如果以合理的方式来组织代码，默认会使用`@SpringBootApplication`类作为测试的配置。

因此，重要的是不要在应用程序的主类中使用特定于特殊功能领域的配置设置。

假设使用了Spring Batch，并且依赖其自动配置，那么可以这样定义`@SpringBootApplication`：

```java
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@EnableBatchProcessing
public class MyApplication {

}
```

因为这个类时测试的源配置，任何切片测试实际上都会尝试启动Spring Batch，这绝不是你想要的。推荐的方法是把特定领域的配置迁移到与应用程序同级的其他`@Configuration`类中。如下所示：

```java
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
@EnableBatchProcessing
public class MyBatchConfiguration {

}
```

<univ-note type="note">

取决于应用程序的复杂性，可以只使用一个`@Configuration`类来进行定制，或者每个领域一个`@Configuration`类。后一种方法在测试时可以使用`@Import`注解（如果需要的话）来启用这些配置。

</univ-note>

测试切片会在扫描时排除`@Configuration`类。例如，对于`@WebMvcTest`而言，以下配置不会在测试切片加载的应用程序上下文中引入给定的`WebMvcConfigurer` Bean：

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration(proxyBeanMethods = false)
public class MyWebConfiguration {

    @Bean
    public WebMvcConfigurer testConfigurer() {
        return new WebMvcConfigurer() {

        };
    }

}
```

但是，以下配置却会导致测试切片加载自定义`WebMvcConfigurer`。

```java
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Component
public class MyWebMvcConfigurer implements WebMvcConfigurer {

}
```

另一种引起混淆的配置源是`classpath`扫描。假设以合理的方式来组织代码，需要扫描其他包，应用程序代码可能类似于：

```java
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;

@SpringBootApplication
@ComponentScan({ "com.example.app", "com.example.another" })
public class MyApplication {

}
```

这样可以有效地覆盖默认的组件扫描指令，带来的副作用是无论选择哪个切片都会扫描这两个包。例如，`@DataJpaTest`似乎会突然扫描应用程序的组件和用户配置。不过，把自定义指令迁移到一个单独的类是解决这个问题的好方法。

<univ-note type="tip">

如果不想选择这种方式，可以在测试层次结构的某个地方创建一个`@SpringBootConfiguration`，这样就会使用这个配置源。另外，也可以给测试指定配置源，这样就会禁用查找默认配置源的行为。

</univ-note>

## 使用Spock来测试Spring Boot应用程序

Spock 2.x可以用于测试Spring Boot应用程序。要这么做的话，需要在应用程序的构建中添加Spock的`spock-spring`模块依赖。`spock-spring`会把Spring的测试框架集成到Spock中。
